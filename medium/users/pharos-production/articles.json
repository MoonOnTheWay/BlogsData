[
    {
        "url": "https://medium.com/pharos-production/outsource-mobile-apps-and-web-services-development-4ea048c2a67?source=---------0",
        "title": "Outsource Mobile Apps and Web Services Development.",
        "text": "Contact us to outsource Mobile Apps \u2014 iOS, Android and Web Services \u2014 social networking, e-commerce etc projects to us as our expertise is extensive making sure it fulfills your project\u2019s requirements on time and within budget and resources. Message us now!"
    },
    {
        "url": "https://medium.com/pharos-production/aws-elastic-beanstalk-part-1-cc0002825d54?source=---------1",
        "title": "Elixir on Elastic Beanstalk. Part 1 \u2014 Virtual Private Cloud.",
        "text": "Now let\u2019s add subnets to the VPC. We will create only public subnets for now. Here we define a new subnet into 1a Availability Zone with a CIDR block 10.0.64.0/20. That means we have 4K ip addresses available in the subnet. For sure this can cover all our needs.\n\nIn Subnet Actions menu we select not to assign public IP addresses to instances. We want to access only database from outside and not instances itself.\n\nAnother thing we should create is an Internet Gateway it possible to communicate with internet.\n\nNext we should define a Routing Table. Here we\u2019re attaching created internet gateway and VPC ip address. On subnet associations we select all created subnetworks. Now all of them are linked to the router and able to connect with each other and with internet too.\n\nAlso we should define subnetwork ACL \u2014 to protect all traffic on a subnetwork\u2019s layer. We have also Security Groups, they do the same but on instance layer. Another difference between ACL as SG is that you define in security group who can access the content, but in ACL you define who can\u2019t. To simplify all our setup for now we define that everyone can come in and out of subnetwork. We should change this in future. It\u2019s a good practice to define rules with numbers like 100, 200, 300 etc. The last one is \u201cother\u201d case if any case have been successed. Later you can insert rules between 100 and 200 just by setting it\u2019s value for example to 120."
    },
    {
        "url": "https://medium.com/pharos-production/swift-concurrency-80a8c475a2f7?source=---------2",
        "title": "Swift. Concurrency. \u2013 Pharos Production \u2013",
        "text": "NSLock class provides unfair lock of the resource. That means if there is a bunch of threads that are waiting for the resource, they will get an access to this resource after unlock but not in the same order as they request it. When many threads trying to acquire a resource and number of lock/unlock operations begin to rise, performance is always going down. NSLock is definitely not the fastest lock.\n\nOSSpinLock. This class polls lock condition until it\u2019s true. This is how @property(atomic) works. And this is a way faster than NSLock, but it wastes CPU time by looping a lock condition. This is a value type! All other locks are reference types. In Objective-C there is a similar to atomic property construction \u2014 @synchronized. It\u2019s not a lock actually, but it treats an arbitrary objective-c object as a lock. One synchronized method will not give other synchronized method to use the same object pointers. Swift realization of this construct looks like this:\n\nNSConditionLock. It provides sublocks in it and it\u2019s easier to build complex locking mechanisms rather than with NSLock. While you\u2019re using NSConditionLock on the one resource with one condition, it acts the same as NSLock.\n\nNSRecursiveLock. We can acquire the same resource by the same thread multiple times without a deadlock. For example in a recursion.\n\nNSCondition. This class make a thread to put on hold until it\u2019s condition not met.\n\nNSSemaphore. There is no NSSemaphore class. Use locks and conditions."
    },
    {
        "url": "https://medium.com/pharos-production/android-recycler-with-cards-and-their-friend-infinite-scroll-1714d43b9cd8?source=---------3",
        "title": "Android. Recycler with Cards, and their friend Infinite Scroll.",
        "text": "Next let\u2019s define a fragment with recycler view in it. I\u2019m using recyclers inside fragments on my current project, but it will be the same if you\u2019re going to use it in activities.\n\nBecause we\u2019re in a fragment context, we define two lifecycle methods.\n\nFirst we inflating a required layout and bind all member variables \u2014 mRecyclerView here.\n\nWe need to define the adapter which will handle all server-model operations. Also we need a layout manager with passing in a context and a span count.\n\nNow we\u2019re ready to setup our recycler view:\n\nWe define only one public method to create fragment object. It should take all initial parameters, but we don\u2019t have any for now.\n\nNow let\u2019s define data loading method. It\u2019s not the best idea to define such methods in a fragment instead of in adapter or somewhere else in a place more related to data rather than to UI. But this is my own prefs and we will do it this way for now.\n\nFirst we check if there is a next page at all. No sense to trigger the server if there is nothing to trigger. Remember, we\u2019re using automated triggering via scroll list position. So we query the server to get all requests. We pass 3 parameters \u2014 current acitivity to show error messages to the user if any, current page and a response anonymous function. If server responding with a success, we receiver a new state for a current page \u2014 new page number, new page size(usually it\u2019s a constant), new total entries number and a new total pages calculated from page size and total entries. Then we add all new data to the adapter and perform adapter update the UI via notifyDataSetChanged() method.\n\nThere are two boilerplate classes we should define to support decorator and scroll listener. Java is full of enterprise-friendly boilerplates.\n\nThe first class is a Scroll Listener. We should define yet another boilerplate required method \u2014 onScrollStateChaged. And more useful method \u2014 onScrolled. All our automation triggering logic is in onScrolled.\n\nAll we need to do here is to check if app is not loading something here and if a new page is in range of total pages number responded by the server previously. If we succeed with this two requirements, than app calls loadData method defined above.\n\nAnother class is a decorator which will prepare a nice layout. There is nothing to explain here, this is just a helper class."
    },
    {
        "url": "https://medium.com/pharos-production/deep-neural-networks-theory-convolutional-networks-332c28ab82ad?source=---------4",
        "title": "Deep Neural Networks. Theory. Convolutional Networks.",
        "text": "ConvNet also contains pooling layers. They sit immediately after convolutional layers. Pooling simplified convolutional output. For example median pooling slides with a 2x2 kernel over convolutional output and computes median of it\u2019s values. One other is a max pooling, it takes maximum of 4 values when a kernel is 2x2. In the result we will have smaller output. Pooling means \u2014 when a feature is found it doesn\u2019t really matter it\u2019s exact location but rough location is enough. There are more different techniques likes L2 pooling.\n\nThe last pooling layer is connected to a couple of fully connected layers. Like on the image on top. BTW, that was LeNet-5 convolutional network."
    },
    {
        "url": "https://medium.com/pharos-production/deep-neural-networks-practice-part-1-c7a60e9bb515?source=---------5",
        "title": "Deep Neural Networks. Practice. Part 1. \u2013 Pharos Production \u2013",
        "text": "We start with imported libraries and data perparations. We will use numpy, Boston House-price Dataset (regression) from SciKitLearn and a couple for utils to rearrange the data \u2014 shuffle and resample.\n\nSKLearn has already prepared two sets for us:\n\nThen we normalizing the data \u2014 adjust values to a notionally common scale. We use standard score here because population is known, it works well for normally distributed populations.\n\nNext we take features from array. X_.shape shows (506, 13). So we have 13 features and 506 training samples. Also we define 10 perceptrons in a hidden layer. Than we should initialize weights with a random uniform distributed values and biases with zeros. W and b with index 1 is weights and biases between input and hidden layer, with index 2 \u2014 between hidden layer and output."
    },
    {
        "url": "https://medium.com/pharos-production/elixir-process-registry-sockets-and-gproc-50c8eaf2ec2d?source=---------6",
        "title": "Elixir. Process Registry. Sockets and gproc. \u2013 Pharos Production \u2013",
        "text": "Last time we have looked at process registry with ETS lookup. That was freaky cool but what should we do with all that stuff? Let make it more interesting. This time we will use process registry to run socket worker. App will listen to a socket(only one for the sake of simplicity) and respond with a dummy message.\n\nTake a look at observer screenshot. On the top of the supervision tree there is a tiny process \u2014 our listener. It was started by an application supervisor and now listens to incoming connections.\n\nLet\u2019s add two new packages to compile time dependencies \u2014 :gporc and :socket. You can find more on screenshot but we will talk about them in future articles.\n\nLet\u2019s replace our Process Registry on to battle tested erlang\u2019s library called Gproc. All we should do is to change via tuple. Else is the same. :n \u2014 means name, :l \u2014 means local. Every process will be registered locally on a node with a unique name.\n\nApplication module starts socket listener in a supervision tree. Simple enough. We pass only one parameter \u2014 port. Surely port should be passed in some other less stupid way, but this time we add it through initialization parameters for the sake of clarity.\n\nSocket listener is not a gen_server as you have been expacted. But it has similar API to make it possible to use from supervision tree. For now we have only one function \u2014 start_link with a port parameter. Start_link spawns a new linked process. We have seen it in application supervisor. This is a dedicated process which listens to the port. Socket sits on top of inet application, you can find extensive documentation here inet\n\nWe start an infinite loop in the init. When connection is established we spawn a new process with a worker inside and back to listen to the next connection.\n\nNow the most interesting part of the module. We should listen to messages and send them to a worker.\n\nWe have Socket receive case handler. In case of nil we pass through the function. In case of closed and halted connections we can skip and return just :ok atom, we don\u2019t care for now. When we receive data we send a cast message to the worker. We send cast because we don\u2019t care of the return value, it will be returned by a socket library. We send a cast message to a process which is registered globally via :gproc. :l \u2014 means locally on the node, :p \u2014 means property and let us set key/value pair for a process, other processes can set a name and value on their own."
    },
    {
        "url": "https://medium.com/pharos-production/elixir-process-registry-erlang-term-storage-2f80ae961815?source=---------7",
        "title": "Elixir. Process Registry. Erlang Term Storage. \u2013 Pharos Production \u2013",
        "text": "To increase lookup performance we should add a way better storage rather than Map. That\u2019s ETS \u2014 Erlang Term Storage \u2014 blazingly fast in-memory key-value storage.\n\nAlmost nothing have changed in API, the only difference is in whereis_name function. It doesn\u2019t call gen_server callback any more, now client will perform all lookup queries. We just pass registry module and a key, and match key with a result. Very straightforward.\n\nAlso there is no new callbacks at all. We just use what we already have but with map replaced with ETS. Also there is no state in registry gen_server any more. All values are inside ETS table.\n\nIn init callback we initialize ETS table with parameters:\n\nRegister_name has only one change \u2014 it adds new row to the table with a key as a key and pid as a value.\n\nDOWN handle_info callback do the same as unregister_name but using pid as a matching pattern because there is no information about the key."
    },
    {
        "url": "https://medium.com/pharos-production/deep-neural-networks-theory-part-2-5cef376890b2?source=---------8",
        "title": "Deep Neural Networks. Theory. Part 2. \u2013 Pharos Production \u2013",
        "text": "To find weights with minimum error, we can tune them in the direction of error minimization like on the image above. Every step is the opposite to the slope \u2014 gradient. If we will go down through the gradient, we can find the minimum error in the bottom \u2014 minimum of the error function.\n\nLet\u2019s define an Error term and Weight Step in a gradient descent. Weight step is proportional to the gradient \u2014 the partial derivative from the error with respect to each step. Then we can set an arbitrary scaling parameter \u2014 learning rate \u2014 which allows to set the size of gradient descent step \u2014 Eta.\n\nSo Error Term is an Error times the activation function. And the weight step is a learning rate times error term times the value of input.\n\nThis formulas is for one output unit. To calculate total error for multiple outputs as a sum of output errors."
    },
    {
        "url": "https://medium.com/pharos-production/deep-neural-networks-theory-part-1-7af6fcfdd59f?source=---------9",
        "title": "Deep Neural Networks. Theory. Part 1. \u2013 Pharos Production \u2013",
        "text": "So how do we use all that weights? The simplest approach is a linear combination of all incoming weights multiplied by their inputs. We will use w for an individual weight and W for a matrix of weights. We express linear combination as a sum:\n\nThen we should emit an output signal from a perceptron. We can use simple step function as a trigger \u2014 Heaviside Step Function \u2014 we call it Activation Function\n\nSo when we have a sum of weights*inputs less than zero \u2014 perceptron should say No. If more than 1 \u2014 Yes. That\u2019s all we need from perceptron for now. Yes or No. But what if we need to move a step to bigger or smaller values? We shoud add Bias. This is just a value which will move our function higher or lower. Now Perceptron formula is. It looks like a linear regression, yeah?\n\nThere are more different activation functions like tanh, sigmoid, softmax etc. Let\u2019s look at sigmoid. We will use. Why? Because in compare to Heaviside function we can take a derivative from sigmoid.\n\nProbably you want to say \u2014 we don\u2019t know weights. How do we calculate all this stuff? Yes, we need to define a metrics of how wrong the prediction is. A common metrics is a Sum of Squared Error (SSE)\n\nWhere y \u2014 is a real value and y-hat \u2014 is a prediction, j \u2014 all output units and mu \u2014 all data points. Formula is quite easy. We find the difference between real value and predicated value, then square it, then sum it. That\u2019s all. Theoretically we can take an absolute value, but square is better \u2014 all errors are positive and larger errors penalized out than lower errors.\n\nWe remember that prediction is a function of sum of multiplications of weights and inputs(say, depends on weights), than finally error is\n\nand it should be as low as possible."
    },
    {
        "url": "https://medium.com/pharos-production/process-registry-dynamic-workers-fb9be88cf6fb",
        "title": "Elixir. Process Registry. Dynamic workers. \u2013 Pharos Production \u2013",
        "text": "Here we create a supervisor to handle future dynamic workers. Start_link takes arguments from Application Module and passing them into supervisor\u2019s start_link function. Supervisor is defined in a local name space.\n\nStart_child is a starting point for every new worker. It takes worker\u2019s name \u2014 it should be unique until worker is dead; and some initial value you want to pass into the worker. Start_child should be called while application running and not on a start like in a \u201cstatic\u201d pool.\n\nIn init callback we define worker signature and it\u2019s restart strategy to temporary \u2014 that means if worker is dead than it\u2019s dead and don\u2019t restart it please."
    },
    {
        "url": "https://medium.com/pharos-production/camera-calibration-opencv-on-ios-8bdb821085e0",
        "title": "Camera calibration. OpenCV on iOS. \u2013 Pharos Production \u2013",
        "text": "Camera has a lens. Lens can distort your image. But why and how? You can read this on wikipedia and 1000+ photography web sites.\n\nOur goal is to remove distortions from image result. We will deal with radial distortions in this article. Why it matters? Fisheye is a perfect radial distortion example \u2014 short focal distance lenses will always distort photos. Low quality lenses loves add distortion too. This type of distortion skew straight lines, so we should undistort camera output before we begin to make image processing. Surely if we care that image is distorted. Usually we don\u2019t, but somtimes. Camera calibration will remove distortion programmatically for us."
    },
    {
        "url": "https://medium.com/pharos-production/process-registry-one-node-pool-c3a56f0f199f",
        "title": "Elixir. Process Registry. One-node pool. \u2013 Pharos Production \u2013",
        "text": "Let\u2019s move from top to bottom. This is our application module. While application starts it spawns a top-level supervisor with two workers on-board and rest-for-one strategy. Rest-for-one \u2014 when worker crashed, supervisor crashing all workers started after the crashed one. Supervisor always starts workers synchronously so if worker Registry will die, than Pool Server should be killed by a supervisor too. Also supervisor has a limit on amount of child restarts, if worker decides to crash infinitely, supervisor crashing by itself and killing all it\u2019s dependencies after that limit amount is over. Be aware of long waiting initiation of workers. Default timeout is 5 seconds, after then process will be killed. If you want to run long waiting initiations \u2014you can find more details here Long-waiting calls.\n\nSo two children here: Registry and a Pool Server.\n\nAs you can guess from it\u2019s name Registry will contain process pids and their related keys. And Pool Server is an interface for workers and workers supervisor."
    },
    {
        "url": "https://medium.com/pharos-production/circular-images-in-your-android-app-using-volley-50f035033ae7",
        "title": "Circular images in your Android app using Volley. \u2013 Pharos Production \u2013",
        "text": "Your app still doesn\u2019t have any image masked with a circle shape and with a nice border around? Let\u2019s add a class to your app and get rid of old rectangular boring images. I can\u2019t say circle is much better than rectangle, but maybe. Anyway, it\u2019s a trend for 2\u20133 years already!\n\nWe will use V0lley framework. Why Volley? Because it\u2019s featured by Google and it\u2019s a really cool framework. So why not? Add Volley to your project dependencies like this and sync gradle.\n\nVolley has a great ready to use class NetworkImageView. There are tons of cool things out of the box like custom loaders, caches etc. We will nest from this class to make it shape our image automatically.\n\nWhat methods should we override now? NetworkImageView contains 3 constructors and a small method setImageBitmap. There are much more great things inside but we will skip them. Look at setImageBitmap. We create a new BitmapDrawable and pass getCircularBitmap(bitmap) method as a second parameter. BitmapDrawable constructor signature is BitmapDrawable(Resources res, Bitmap bitmap). This method is exactly what we use to assign our future result.\n\nThis is our method and it\u2019s really straightforward. Let\u2019s go step-by-step through.\n\nFirst of all we define new future image by defining a canvas with the size equal to original image. It has 4 channels RGB and A. That\u2019s 8 bit image. Also let\u2019s define stroke width. Surely you should define it outside of the class but we will do this inside the method for the sake of clarity. Also we should find smallest side of an image bounding box, that will be our diameter.\n\nColor constant is 8 bits integer which is a mask color. It should be white to work well with blending mode which is SRC_IN:\n\nNext we set anti alias flag to true to avoid aliased edge. Fill background with black color. Set white color and draw a circle on canvas. Then draw a bitmap on top of the circle and set blending mode.\n\nNext add a stroke using predefined stroke width and set your favorite color. It should be set outside of the class but we set it here for the sake of clarity too. The last 3 rows define and draw a nice circle around the image.\n\nThat\u2019s it! You can find full source code here: pharosproduction/CircularNetworkImageView.java"
    },
    {
        "url": "https://medium.com/pharos-production/long-waiting-sync-calls-using-otp-genserver-or-when-poolboy-is-on-a-vacation-94905af3f85d",
        "title": "Elixir. Long waiting sync calls using OTP GenServer or \u201cwhen Poolboy is on a vacation\u201d",
        "text": "Let\u2019s assume we have a long waited GenServer initialization. That can be anything from a cold storage start to remote call to a thirdparty service. GenServer has a default timout set to 5 seconds. You can easily crash your supervisor initialization just by waiting for children initializations. So what should we do? That\u2019s quite strightforward \u2014 GenServer should send asynchronous request to itself and immediately send :ok response to it\u2019s supervisor. Let\u2019s see how to do that.\n\nThis is our synchronous GenServer. As you can see init callback contains long-waiting task and respond with a nil state. Surely both sleep and nil state are just an example for our toy use case. Don\u2019t ever do like this. Send back something that make sense.\n\nLet\u2019s fire a brand new IEX and test our initialization.\n\nAs we expected we need to wait for 3 seconds then receive a success tuple. So how do we make it asynchronously? Check this out! We\u2019re using simple send function and handle_info callback. One more thing, if you\u2019re adding new handle_info callback to your module, don\u2019t forget to handle all possible use cases. You always should be saved from mailbox overloading. You can skip boilerplate catch all use case when you\u2019re not using handle info, Elixir do this for you.\n\nLet\u2019s try this in a shell. This time return is super fast and initialization has been spawned in a concurrent process! Cool!"
    },
    {
        "url": "https://medium.com/pharos-production/road-lane-recognition-with-opencv-and-ios-a892a3ab635c",
        "title": "Road lanes recognition with OpenCV, Python and iOS \u2013 Pharos Production \u2013",
        "text": "This is my first assignment at Udacity Self-Driving Car Engineer Nanodegree. Udacity proposed to use Python, I like Python but I want something more practical rather than a toy project. So I decided to build the same functionality developed with Python but for iOS and with Swift and C++. And use it on a real road and probably it should recognize lanes in a realtime. We will check that later because this story is just about lanes on the image.\n\nUPDATE: I\u2019m extending this article already going through Term 1 assignments. We\u2019re using Python extensively so article contains Python snippets too. Python version doesn\u2019t have any performance improvements, it\u2019s just a proof of concept."
    },
    {
        "url": "https://medium.com/pharos-production/swift-quick-hints-setters-getters-3febb99ebde",
        "title": "Swift Quick Hints. Setters & Getters. \u2013 Pharos Production \u2013",
        "text": "Just in case you didn\u2019t know \u2014 this is a setter on the image below.\n\nJust kidding. So how to assign a value to swift class or struct variables. You can do it like this.\n\nWhat if you want to change title in immutable struct to some other value? You can change it from let to var. Nothing new for us. But this code smells.\n\nWhat if you want to do something with the title before storing it in your already mutable struct? And you don\u2019t want smelling code. Of course you do it like this.\n\nNow let\u2019s get a title. Title is a private now so we should add a new getter function.\n\nNow it looks like old school Java boilerplate code from 90\u2019s. Let\u2019s make something with that. We can make it like this and get rid of initializer and getter. Actually don\u2019t do this because your variable becomes public.\n\nWatch this. You can say that variable has private setter but public getter just in a one line of code.\n\nWe have more syntax sugar inside Swift. Example belowe is just an illustration. Don\u2019t try to find a meaning of life here. newTitle is a computed property, it acts only like a getter and setter for a title. Title is also accessible from outside. In a computed property you can access a new value in a setter via newValue variable\n\nYet another way to change something related to New Value event is to use willSet and didSet triggers. Take a look at the code below. App assigns value to a variable title in a didSet trigger and it doesn\u2019t fall into infinite loop here! Amazing! Also you can use oldValue in didSet to get, well, and old value."
    },
    {
        "url": "https://medium.com/pharos-production/swift-in-production-method-dispatch-mechanisms-d5f70784f516",
        "title": "Swift in Production. Method Dispatch Mechanisms \u2013 Pharos Production \u2013",
        "text": "This type is used by C and it\u2019s the fastest. No dynamic stuff at all. Compiler knows what to call and when already while building. You can inject code directly during compilation(inline) and there are different performance improvements etc etc. The only one thing we should remember here is \u2014 Direct Dispatch make your app runs faster but you can\u2019t use subclasses.\n\nThis is the most popular type of dispatch across current languages. Java, Perl, JS and many other of them use it as default dispatch method. It works quite strightforward, every class has a table with pointers on functions. Every subclass contains it\u2019s own copy of such table with all new methods on the bottom of the table. It\u2019s impossible to inject in this table, only append to the bottom. That\u2019s why categories and extensions doesn\u2019t work here. In runtime app uses this table to understand where is the required method. While compiler can optimize Direct Dispatch calls, it can\u2019t optimize Table Dispatch. So it\u2019s much slower then Direct.\n\nIt\u2019s the slowest one. When you create a class which is a subclass of another class which is a subclass of some other class and app will decide at runtime what method of which parent it should use \u2014 this is Dynamic Dispatch. Slow but runtimely powerful. You can do different stuff like Key Value Observing and Method Swizzling(hope you don\u2019t really do this) just because you have Dynamic Dispatch in your compiler\u2019s arsenal. To call a function program should dig into the class checking one by one all of it\u2019s methods to find a required one. Of course performance is low, even with the help of different caches."
    },
    {
        "url": "https://medium.com/pharos-production/using-opencv-in-a-swift-project-679868e1b798",
        "title": "Using OpenCV in a Swift project \u2013 Pharos Production \u2013",
        "text": "We will use objective-c++ wrapper to use OpenCV c++ library.\n\n2. Create a new objective-c class OpenCVWrapper which is a subclass of NSObject. Then XCode will ask you to create bridging header. Say Yes. We need to link objective-c classes with swift and this is our glue.\n\nIf you\u2019re going to change bridging header\u2019s path to some other directory, you will need to fix path to header after you move it. It\u2019s really easy, just type \u201cbridging\u201d in project\u2019s build settings and you will find it.\n\n3. Next we should create all required UI because we want to test our new opencv cool stuff on our new friend Mandrill(we will take Mandrill rather than Lena just because he\u2019s less sexy and a bit more funnier). I will not provide any user interface creation step here because it\u2019s not relevant to this article. You can find working code on Github.\n\n4. So far so good. We have our objective-c wrapper class which is PONSO(Plain Old NSObject) and can be natively used in swift classes. The only one small thing we should change is to rename it from .m to .mm so it\u2019s now Objective-C++."
    }
]