[
    {
        "url": "https://medium.com/jim-fleming/loading-tensorflow-graphs-via-host-languages-be10fd81876f?source=tag_archive---------0----------------", 
        "text": "Check out the related post: Loading a TensorFlow graph with the C++ API.\n\nEven though the full C API for TensorFlow is not yet available, we can still use it load TensorFlow graphs and evaluate them from other languages. This is incredibly useful for embedding pre-trained models in other applications. Embedding is one of the most interesting use cases for TensorFlow as it cannot be accomplished as easily with Theano.\n\nNote that while all of the examples here will use Node.js the steps are nearly identical in any language with C FFI support (e.g. Rust, Go, C#, etc.)\n\nWe\u2019ll start by compiling a shared library from TensorFlow using Bazel.\n\nUPDATE: The following build rule for creating a shared library is now part of TensorFlow: https://github.com/tensorflow/tensorflow/pull/695\n\nBelow is the complete BUILD file:\n\nNow that we have our shared library, create a new folder for the host language. Since this is for Node.js I\u2019ll name it tensorflowjs/. This folder can exist outside of the TensorFlow repo since we now have everything needed in the shared library. Copy libtensorflow.so into the new folder.\n\nIf you\u2019re on OS X and using Node.js you\u2019ll need to rename the shared library from libtensorflow.so to libtensorflow.dylib. TensorFlow produces an\u00a0.so however the standard on OS X is dylib. The Node FFI library doesn\u2019t look for\u00a0.so, only\u00a0.dylib; however it can read both formats, so we just rename it.\n\nJust like with the previous C++ tutorial we\u2019re going to create a minimal graph and write it to a protobuf file. (Be sure to name your variables and operations.)\n\nNow we can go through the TensorFlow C API header, almost line by line, and write the appropriate binding. Most of the time this is fairly direct, simply copying the signature of the function. I also created variables for many of the common types so they were more legible. For example, any structs which map to void* I declared as variables named after the struct. We can also use the ref-array Node module which provides helpers for types like long long* (essentially an array of long long types) so we\u2019ll define a LongLongArray type to correspond. Otherwise, we just copy the signature:\n\nI also defined a few helper functions to eliminate some of the boilerplate when working with the TensorFlow interface. The first is TF_Destructor, a default tensor destructor for TF_NewTensor. This comment in the TensorFlow source makes it sound like it\u2019s optional but it\u2019s not:\n\nAdditionally, many TensorFlow functions return a TF_Status struct and checking the status can get tedious. So I defined a function called TF_CheckOK that simply checks if the status code is TF_OK using TF_GetCode. If its not, we throw an error using TF_Message to hopefully get a useful error message. (This function loosely corresponds to TF_CHECK_OK in the TensorFlow source.)\n\nAnd finally, reading a tensor with TF_TensorData only returns a pointer but to actually read the data we need to extend the returned Buffer to the appropriate length. Creating a Buffer with the correct size is a few lines of boiler plate so I wrapped TF_TensorData to create TF_ReadTensorData which handles that boilerplate for us. Here are the helpers:\n\nNow that we\u2019ve defined our interface the steps for loading the graph are the same as with C++:\n\nWe can load and execute TensorFlow graphs from Node.js! I\u2019ve put the whole thing together into a repo here (you\u2019ll need to provide graph.pb and libtensorflow.dylib since they\u2019re kinda large): https://github.com/jimfleming/tensorflowjs\n\nFollow me on Twitter for more posts like these. If you\u2019d like help deploying TensorFlow in production, I do consulting.", 
        "title": "Loading TensorFlow graphs from Node.js \u2013 Jim Fleming \u2013"
    }
]