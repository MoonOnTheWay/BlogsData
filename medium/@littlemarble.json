[
    {
        "url": "https://towardsdatascience.com/automatic-feature-engineering-using-generative-adversarial-networks-8e24b3c16bf3?source=user_profile---------1----------------",
        "title": "Automatic feature engineering using Generative Adversarial Networks",
        "text": "The purpose of deep learning is to learn a representation of high dimensional and noisy data using a sequence of differentiable functions, i.e., geometric transformations, that can perhaps be used for supervised learning tasks among other tasks. It has had great success in discriminative models while generative models have not fared perhaps quite as well due to the limitations of explicit maximum likelihood estimation (MLE). Adversarial learning as presented in the Generative Adversarial Network (GAN) aims to overcome these problems by using implicit MLE.\n\nWe will use the MNIST computer vision dataset and a synthetic financial transactions dataset for an insurance task for these experiments using GANs. GANs are a remarkably different method of learning compared to explicit MLE. Our purpose will be to show that the representation learnt by a GAN can be used for supervised learning tasks such as image recognition and insurance loss risk prediction. In this manner we avoid the manual process of handcrafted feature engineering by learning a set of features automatically, i.e., representation learning.\n\nThis article can be seen as a follow up to this article: https://goo.gl/TjB2v3\n\nThere are 2 main components to a GAN, the generator and the discriminator, that play an adversarial game against each other. In doing so the generator learns how to create realistic synthetic samples from noise, i.e., the latent space z, while the discriminator learns how to distinguish between a real sample and a synthetic sample.\n\nThe representation learnt by the discriminator can be used for other supervised learning tasks, i.e., automatic feature engineering or representation learning. This can also be viewed through the lens of transfer learning. A GAN can also be used for semi-supervised learning which we will get to in another paper where we will look into using variational autoencoders, ladder networks and adversarial autoencoders for this purpose.\n\nWe will use the MNIST dataset for this purpose where the raw data is a 2 dimensional tensor of pixel intensities per image. The image is our unit of analysis: We will predict the probability of each class for each image. This is a multiclass classification task and we will use the accuracy score to assess model performance on the test fold.\n\nSome examples of handcrafted feature engineering for the computer vision task perhaps might be using Gabor filters.\n\nWe will use a synthetic dataset where the raw data is a 2 dimensional tensor of historical policy level information per policy-period combination: Per unit this will be a 4 by 3 dimensional tensor, i.e., 4 historical time periods and 3 transactions types. The policy-period combination is our unit of analysis: We will predict the probability of loss for time period 5 in the future \u2014 think of this as a potential renewal of the policy for which we need to predict whether it would make a loss for us or not hence affecting whether we decided to renew the policy and / or adjust the renewal premium to take into account the additional risk. This is a binary class classification task and we will use the AUROC score to assess model performance.\n\nSome examples of handcrafted feature engineering for the insurance task perhaps might be using column or row averages.\n\nThe synthetic insurance financial transactions dataset was coded in R. All the rest of the work is done in Python.\n\nPlease note the similarities between the raw data for the computer vision task and the raw data for the insurance task. Our main goal here is to learn a good representation of this raw data using automatic feature engineering via GANs.\n\nWe will use the Python machine learning library scikit-learn for data transformation and the classification task. We will code the GANs as scikit-learn transformers such that they can be readily used by scikit-learn pipelines. The GANs will be coded using Keras with the TensorFlow backend. We also use an external GPU, i.e., GTX 1070, on a MacBook Pro.\n\nAssume that we have a prior belief on where the latent space z lies: p(z). Given a draw from this latent space the generator G, a deep learner, outputs a synthetic sample.\n\nThe discriminator D is another deep learner and it aims to classify if a sample is real or synthetic, i.e., if a sample is from the real data distribution,\n\nLet us denote the discriminator D as follows.\n\nHere we assume that the positive examples are from the real data distribution while the negative examples are from the synthetic data distribution.\n\nA GAN simultaneously trains the discriminator to correctly classify real and synthetic examples while training the generator to create synthetic examples such that the discriminator incorrectly classifies real and synthetic examples. This 2 player minimax game has the following objective function.\n\nPlease note that the above expression is basically the objective function of the discriminator.\n\nIt is clear from how the game has been set up that we are trying to obtain a solution for D such that it maximises V(D, G) while simultaneously we are trying to obtain a solution for G such that it minimizes V(D, G).\n\nWe do not simultaneously train D and G. We train them alternately: Train D and then train G while freezing D. We repeat this for a fixed number of steps.\n\nIf the synthetic samples taken from the generator G are realistic then implicitly we have learnt the synthetic data distribution. In other words, the synthetic data distribution can be seen as a good estimation of the real data distribution. The optimal solution will be as follows.\n\nTo show this let us find the optimal discriminator given a generator G and sample x.\n\nLet us take a closer look at the discriminator\u2019s objective function for a sample x.\n\nWe have found the optimal discriminator given a generator. Let us focus now on the generator\u2019s objective function which is essentially to minimize the discriminator\u2019s objective function.\n\nWe will note the Kullback\u2013Leibler (KL) divergences in the above objective function for the generator.\n\nIf lambda takes the value of 0.5 this is then called the Jensen-Shannon (JS) divergence. This divergence is symmetric and non-negative.\n\nKeeping this in mind let us take a look again at the objective function of the generator.\n\nIt is clear from the objective function of the generator above that the global minimum value attained is -log(4) which occurs when the following holds.\n\nWhen the above holds the Jensen-Shannon divergence between the real data distribution and the synthetic data distribution will be zero. Hence we have shown that the optimal solution is as follows.\n\nAssuming that the discriminator is allowed to reach its optimum given a generator, then\n\ncan be shown to converge to\n\nConsider the following objective function which has been previously shown to be convex with respect to\n\nas we found the global minimum at -log(4).\n\nGradient descent is used by the generator to move towards the global minimum given an optimal discriminator. We will show that the gradient of the generator exists given an optimal discriminator, i.e.,\n\nsuch that convergence of\n\nNote that the following is a supremum of a set of convex functions where the set is indexed by the discriminator:\n\nRemember that the supremum is the least upper bound.\n\nLet us recall a few definitions regarding gradients and subgradients. A vector\n\nIf f is convex and differentiable then its gradient at a point x is also the subgradient. Most importantly, a subgradient can exist even if f is not differentiable.\n\nThe subgradients of the supremum of a set of convex functions include the subgradient of the function at the point where the supremum is attained. As mentioned earlier, we have already shown that\n\nThe gradient of the generator\n\nis used to make incremental improvements to the objective function of the generator\n\ngiven an optimal discriminator D*. Therefore convergence of\n\nIn these experiments we show the ability of the generator to create realistic synthetic examples for the MNIST dataset and the insurance dataset. We use a 2-dimensional latent manifold.\n\nFinally we show that using the representation learnt by the discriminator we can attain competitive results to using other representation learning methods for the MNIST dataset and the insurance dataset such as a wide variety of autoencoders as shown in this article: https://goo.gl/TjB2v3\n\nWith image data we can perhaps judge qualitatively whether the generated data makes sense. For financial transactions data this is not possible. However let us have a look at an example of a generated transactions lattice. Please note that all financial transactions data has been transformed to lie between 0 and 1.\n\nIf we use the same matplotlib code as applied to the image data to plot the above generated transactions lattice we get the following image. We can see that where we have the maximum value possible for a transaction, i.e., 1, that is colored as black, while where we have the minimum value possible for a transaction, i.e., 0, that is colored as white. Transactions values in between have some gray color.\n\nFinally let us compare the distributions of actual and generated transactions lattices to see whether generated values are similar to actual values. This is a simple sanity check and it appears that the distributions are fairly similar.\n\nAnother way perhaps is to check if the features learnt by the discriminator are useful for a supervised learning task. This seems to be the case in our insurance data example especially if we compare their performance with autoencoders for the same task here: https://goo.gl/TjB2v3\n\nCompare these results with using autoencoders for representation learning for the same computer vision and insurance tasks here: https://goo.gl/TjB2v3\n\nThe code I\u2019ve written for this article is available on my GitHub here: https://github.com/hamaadshah/gan_public\n\nWe have shown how to use GANs to learn a good representation of raw data, i.e., 2 dimensional tensors per unit of analysis, that can then perhaps be used for supervised learning tasks in the domain of computer vision and insurance. This moves us away from manual handcrafted feature engineering towards automatic feature engineering, i.e., representation learning. GANs can perhaps be also used for semi-supervised learning which will be the topic of another paper."
    },
    {
        "url": "https://towardsdatascience.com/automatic-feature-engineering-using-deep-learning-and-bayesian-inference-application-to-computer-7b2bb8dc7351?source=user_profile---------2----------------",
        "title": "Automatic feature engineering using deep learning and Bayesian inference",
        "text": "We will explore the use of deep learning and Bayesian inference for automatic feature engineering, specifically autoencoders. The idea is to automatically learn a set of features from, potentially noisy, raw data that can be useful in supervised learning tasks such as in computer vision and insurance. In this manner we avoid the manual process of handcrafted feature engineering by learning a set of features automatically, i.e., representation learning, that can help in solving certain tasks such as image recognition and insurance loss risk prediction.\n\nWe will use the MNIST dataset for this purpose where the raw data is a 2 dimensional tensor of pixel intensities per image. The image is our unit of analysis: We will predict the probability of each class for each image. This is a multiclass classification task and we will use the accuracy score to assess model performance on the test fold.\n\nSome examples of handcrafted feature engineering for the computer vision task perhaps might be using Gabor filters.\n\nWe will use a synthetic dataset where the raw data is a 2 dimensional tensor of historical policy level information per policy-period combination: Per unit this will be a 4 by 3 dimensional tensor, i.e., 4 historical time periods and 3 transactions types. The policy-period combination is our unit of analysis: We will predict the probability of loss for time period 5 in the future \u2014 think of this as a potential renewal of the policy for which we need to predict whether it would make a loss for us or not hence affecting whether we decided to renew the policy and / or adjust the renewal premium to take into account the additional risk. This is a binary class classification task and we will use the AUROC score to assess model performance.\n\nSome examples of handcrafted feature engineering for the insurance task perhaps might be using column or row averages.\n\nThe synthetic insurance financial transactions dataset was coded in R. All the rest of the work is done in Python.\n\nPlease note the similarities between the raw data for the computer vision task and the raw data for the insurance task. Our main goal here is to learn a good representation of this raw data using automatic feature engineering via deep learning and Bayesian inference.\n\nWe will use the Python machine learning library scikit-learn for data transformation and the classification task. Note that we will code the autoencoders as scikit-learn transformers such that they can be readily used by scikit-learn pipelines. The deep learners will be coded using Keras with the TensorFlow backend. We also use an external GPU, i.e., GTX 1070, on a MacBook Pro.\n\nWe run the MNIST dataset without using an autoencoder. The 2 dimensional tensor of pixel intensities per image for MNIST images are of dimension 28 by 28. We reshape them as a 1 dimensional tensor of dimension 784 per image. Therefore we have 784 features for this supervised learning task per image.\n\nWe use a PCA filter that picks the number of components that explain 99% of the variation.\n\nAn autoencoder is an unsupervised learning technique where the objective is to learn a set of features that can be used to reconstruct the input data.\n\nOur input data is X. An encoder function E maps this to a set of K features. A decoder function D uses the set of K features to reconstruct the input data.\n\nLets denote the reconstructed data as follows.\n\nThe goal is to learn the encoding and decoding functions such that we minimize the difference between the input data and the reconstructed data. An example for an objective function for this task can be the Mean Squared Error (MSE).\n\nWe learn the encoding and decoding functions by minimizing the MSE using the parameters that define the encoding and decoding functions: The gradient of the MSE with respect to the parameters are calculated using the chain rule, i.e., backpropagation, and used to update the parameters via an optimization algorithm such as Stochastic Gradient Descent (SGD).\n\nLets assume we have a single layer autoencoder using the Exponential Linear Unit (ELU) activation function, batch normalization, dropout and the Adaptive Moment (Adam) optimization algorithm. B is the batch size, K is the number of features.\n\nThe idea here is to add some noise to the data and try to learn a set of robust features that can reconstruct the non-noisy data from the noisy data. The MSE objective functions is as follows.\n\nSo far we have used flattened or reshaped raw data. Such a 1 dimensional tensor of pixel intensities per image might not take into account useful spatial features that the 2 dimensional tensor might contain. To overcome this problem, we introduce the concept of convolution filters, considering first their 1 dimensional version and then their 2 dimensional version.\n\nThe ideas behind convolution filters are closely related to handcrafted feature engineering: One can view the handcrafted features as simply the result of a predefined convolution filter, i.e., a convolution filter that has not been learnt based on the raw data at hand.\n\nSuppose we have raw transactions data per some unit of analysis, i.e., mortgages, that will potentially help us in classifying a unit as either defaulted or not defaulted. We will keep this example simple by only allowing the transaction values to be either $100 or $0. The raw data per unit spans 5 time periods while the defaulted label is for the next period, i.e., period 6. Here is an example of a raw data for a particular unit:\n\nSuppose further that if the average transaction value is $20 then we will see a default in period 6 for this particular mortgage unit. Otherwise we do not see a default in period 6. The average transaction value is an example of a handcrafted feature: A predefined handcrafted feature that has not been learnt in any manner. It has been arrived at via domain knowledge of credit risk. Denote this as H(x).\n\nThe idea of learning such a feature is an example of a 1 dimensional convolution filter. As follows:\n\nAssuming that H(x) is the correct representation of the raw data for this supervised learning task then the optimal set of parameters learnt via supervised learning for the convolution filter defined above, or perhaps unsupervised learning and then transferred to the supervised learning task, i.e., transfer learning, is [0.2, 0.2, 0.2, 0.2, 0.2]:\n\nThis is a simple example however this clearly illusrates the principle behind using deep learning for automatic feature engineering or representation learning. One of the main benefits of learning such a representation in an unsupervised manner is that the same representation can then be used for multiple supervised learning tasks: Transfer learning. This is a principled manner of learning a representation from raw data.\n\nTo summarize the 1 dimensional convolution filter for our simple example is defined as:\n\nThis automates feature engineering however introduces architecture engineering where different architectures consisting of various convolution filters, activation functions, batch normalization layers, dropout layers and pooling operators can be stacked together in a pipeline in order to learn a good representation of the raw data. One usually creates an ensemble of such architectures.\n\nThe goal behind convolutional autoencoders is to use convolution filters, activation functions, batch normalization layers, dropout layers and pooling operators to create an encoder function which will learn a good representation of our raw data. The decoder will also use a similar set of layers as the encoder to reconstruct the raw data with one exception: Instead of using a pooling operator it will use an upsampling operator. The basic idea behind the upsampling operator is to repeat an element a certain number of times say size 4: One can view this as the inverse operator to the pooling operator. The pooling operator is essentially a downsampling operator and the upsampling operator is simply the inverse of that in some sense.\n\nGiven our mortgage default example a potentially more useful deep learning architecture might be the Recurrent Neural Network (RNN), specifically their state of the art variant the Long Short Term Memory (LSTM) network. The goal is to explicitly take into account the sequential nature of the raw data.\n\nThe gradients in a RNN depend on the parameter matrices defined for the model. Simply put these parameter matrices can end up being multiplied many times over and hence cause two major problems for learning: Exploding and vanishing gradients. If the spectral radius of the parameter matrices, i.e., the maximum absolute value of the eigenvalues of a matrix, is more than 1 then gradients can become large enough, i.e., explode in value, such that learning diverges and similarly if the spectral radius is less than 1 then gradients can become small, i.e., vanish in value, such that the next best transition for the parameters cannot be reliably calculated. Appropriate calculation of the gradient is important for estimating the optimal set of parameters that define a machine learning method and the LSTM network overcomes these problems in a vanilla RNN. We now define the LSTM network for 1 time step, i.e., 1 memory cell.\n\nWe calculate the value of the input gate, the value of the memory cell state at time period t where f(x) is some activation function and the value of the forget gate:\n\nThe forget gate controls the amount the LSTM remembers, i.e., the value of the memory cell state at time period t-1 where \u2a02 is the hadamard product:\n\nWith the updated state of the memory cell we calculate the value of the outputs gate and finally the output value itself:\n\nWe can have a wide variety of LSTM architectures such as the convolutional LSTM where note that we replace the matrix multiplication operators in the input gate, the initial estimate of the memory cell state, the forget gate and the output gate by the convolution operator *:\n\nAnother popular variant is the peephole LSTM where the gates are allowed to peep at the memory cell state:\n\nThe goal for the sequence to sequence autoencoder is to create a representation of the raw data using a LSTM as an encoder. This representation will be a sequence of vectors learnt from a sequence of raw data vectors. The final vector of the representation is our encoded representation, also called a context vector. This context vector is repeated as many times as the length of the sequence such that it can be used as an input to a decoder which is yet another LSTM. The decoder LSTM will use this context vector to recontruct the sequence of raw data vectors. If the context vector is useful in the recontruction task then it can be further used for other tasks such as predicting default risk as given in our example.\n\nWe now combine Bayesian inference with deep learning by using variational inference to train an autoencoder. This moves us towards generative modelling which can have further use cases in semi-supervised learning. The other benefit of training using Bayesian inference is that we can be more robust to higher capacity deep learners.\n\nFor 2 dimensional convolution filters the idea is similar as for the 1 dimensional convolution filters. We will stick to our previously mentioned banking example to illustrate this point.\n\nIn the 2 dimensional tensor of raw transactions data now we have 5 historical time periods, i.e., the rows, and 3 different transaction types, i.e., the columns. We will use a kernel of size 2 by 3 to extract useful features from the raw data. The choice of such a kernel means that we are interested in finding a feature map across all 3 transaction types and 2 historical time periods. We will use a stride length of 1 and a valid convolution to extract features over different patches of the raw data. The following will illustrate this point.\n\nThe principles and ideas apply to 2 dimensional convolution filters as they do for their 1 dimensional counterparts there we will not repeat them here.\n\nWe now proceed to run the insurance model without any handcrafted or deep learning based feature engineering: Just raw data.\n\nWe now proceed to run the insurance model without any handcrafted or deep learning based feature engineering however with a PCA filter that picks the number of components that explain 99% of the variation.\n\nIn this case we have created some handcrafted features which we believe provide a useful representation of the raw data for the insurance model.\n\nWe use the aforementioned handcrafted features and a PCA filter that picks the number of components that explain 99% of the variation.\n\nIn this case we use vanilla autoencoders to learn a good representation of the raw data such that we can obtain an uplift, in terms of AUROC, for the supervised learning task.\n\nIn this case we use denoising autoencoders to learn a good representation of the raw data such that we can obtain an uplift, in terms of AUROC, for the supervised learning task.\n\nIn this case we use sequence to sequence autoencoders, taking into account the time series nature, i.e., sequential nature, of the raw transactions data, to learn a good representation of the raw data such that we can obtain an uplift, in terms of AUROC, for the supervised learning task.\n\nIn this case we use 1 dimensional convolutional autoencoders to learn a good representation of the raw data such that we can obtain an uplift, in terms of AUROC, for the supervised learning task.\n\nIn this case we use 2 dimensional convolutional autoencoders to learn a good representation of the raw data such that we can obtain an uplift, in terms of AUROC, for the supervised learning task.\n\nIn this case we use variational autoencoders to learn a good representation of the raw data such that we can obtain an uplift, in terms of AUROC, for the supervised learning task.\n\nAs expected, the best score achieved here is by a 2 dimensional convolutional autoencoder.\n\nThe best score achieved on this task is by a vanilla autoencoder. This highlights the automation of feature engineering via deep learning: I believe it was Ian Goodfellow who said that a learnt representation is better than a handcrafted representation.\n\nNote that the sequence to sequence and convolutional autoencoders did not do well on this task simply because of the manner in which I generated the synthetic transactions data: Should the data have been from a process more amenable to sequence to sequence or convolutional autoencoders it is highly likely that these architectures would\u2019ve performed better.\n\nThe code I\u2019ve written for this article is available on my GitHub here: https://github.com/hamaadshah/autoencoders_public\n\nWe have shown how to use deep learning and Bayesian inference to learn a good representation of raw data, i.e., 1 or 2 dimensional tensors per unit of analysis, that can then perhaps be used for supervised learning tasks in the domain of computer vision and insurance. This moves us away from manual handcrafted feature engineering towards automatic feature engineering, i.e., representation learning. This does introduce architecture engineering however that can be automated as well perhaps by the use of genetic algorithms or reinforcement learning \u2014 a topic for another paper perhaps.\n\nFinally, I would like to emphasize that the same code used for solving the computer vision task was used to solve the insurance task. In both tasks automatic feature engineering via deep learning had the best performance despite the fact that we were not explicitly looking for the best state of the art architecture possible. This provides us with a powerful way of automating machine learning tasks end-to-end."
    }
]